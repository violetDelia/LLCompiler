Args: /home/lfr/LLCompiler/build/bin/llc-opt --split-input-file --canonicalize /home/lfr/LLCompiler/test/Dialect/LLH/canonicalize_symbol.mlir -debug 
Load new dialect in Context builtin
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ShapedType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemRefLayoutAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::TypedAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ElementsAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DistinctAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BytecodeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionKindInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ConditionallySpeculatable)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffectOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ResourceBlobManagerDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BytecodeDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineBinaryOpExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineConstantExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineDimExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineMapStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::IntegerSetStorage)
Load new dialect in Context builtin
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroOperands<mlir::TypeID::get<mlir::OpTrait::ZeroOperands>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneRegion<mlir::TypeID::get<mlir::OpTrait::OneRegion>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroResults<mlir::TypeID::get<mlir::OpTrait::ZeroResults>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroSuccessors<mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NoRegionArguments<mlir::TypeID::get<mlir::OpTrait::NoRegionArguments>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NoTerminator<mlir::TypeID::get<mlir::OpTrait::NoTerminator>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SingleBlock<mlir::TypeID::get<mlir::OpTrait::SingleBlock>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OpInvariants<mlir::TypeID::get<mlir::OpTrait::OpInvariants>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BytecodeOpInterface::Trait<mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AffineScope<mlir::TypeID::get<mlir::OpTrait::AffineScope>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsIsolatedFromAbove<mlir::TypeID::get<mlir::OpTrait::IsIsolatedFromAbove>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SymbolTable<mlir::TypeID::get<mlir::OpTrait::SymbolTable>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolOpInterface::Trait<mlir::TypeID::get<mlir::SymbolOpInterface::Trait>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmOpInterface::Trait<mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionKindInterface::Trait<mlir::TypeID::get<mlir::RegionKindInterface::Trait>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasOnlyGraphRegion<mlir::TypeID::get<mlir::OpTrait::HasOnlyGraphRegion>()::Empty>)
Load new dialect in Context llh
Load new dialect in Context mlir_ex
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolicInferShapeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolUserOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BraodcastableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferTypeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CastOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DialectInlinerInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LLVMTranslationDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroRegions<mlir::TypeID::get<mlir::OpTrait::ZeroRegions>()::Empty>)
Load new dialect in Context func
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::FunctionOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchTerminatorOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ConvertToLLVMPatternInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::bufferization::BufferizableOpInterface)
Load new dialect in Context cf
Load new dialect in Context arith
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::ArithFastMathInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::VectorUnrollOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferIntRangeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::ArithIntegerOverflowFlagsInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::ArithRoundingModeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SelectLikeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::bufferization::BufferDeallocationOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ValueBoundsOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BranchOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AutomaticAllocationScope<mlir::TypeID::get<mlir::OpTrait::AutomaticAllocationScope>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallableOpInterface::Trait<mlir::TypeID::get<mlir::CallableOpInterface::Trait>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::FunctionOpInterface::Trait<mlir::TypeID::get<mlir::FunctionOpInterface::Trait>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::VerifiableTensorEncoding)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::VariadicOperands<mlir::TypeID::get<mlir::OpTrait::VariadicOperands>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl<mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ConditionallySpeculatable::Trait<mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffectOpInterface::Trait<mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::MemRefsNormalizable<mlir::TypeID::get<mlir::OpTrait::MemRefsNormalizable>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchTerminatorOpInterface::Trait<mlir::TypeID::get<mlir::RegionBranchTerminatorOpInterface::Trait>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ReturnLike<mlir::TypeID::get<mlir::OpTrait::ReturnLike>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsTerminator<mlir::TypeID::get<mlir::OpTrait::IsTerminator>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::ModuleOpGenericAdaptorBase::Properties)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolUserOpInterface::Trait<mlir::TypeID::get<mlir::SymbolUserOpInterface::Trait>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutSpecInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneResult<mlir::TypeID::get<mlir::OpTrait::OneResult>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NOperands<2>::Impl<mlir::TypeID::get<mlir::OpTrait::NOperands<2>::Impl>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ResultsBroadcastableShape<mlir::TypeID::get<mlir::OpTrait::ResultsBroadcastableShape>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BraodcastableOpInterface::Trait<mlir::TypeID::get<mlir::BraodcastableOpInterface::Trait>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolicInferShapeOpInterface::Trait<mlir::TypeID::get<mlir::SymbolicInferShapeOpInterface::Trait>()::Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::OpToOpPassAdaptor)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DialectFoldInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ConstantLike<mlir::TypeID::get<mlir::OpTrait::ConstantLike>()::Empty>)

//===-------------------------------------------===//
Processing operation : 'llh.symbolic_int'(0x55e33ca98af0) {
  "llh.symbolic_int"() <{sym_name = "s5"}> : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llh.symbolic_int'(0x55e33ca98fc0) {
  "llh.symbolic_int"() <{sym_name = "s4"}> : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llh.symbolic_int'(0x55e33ca99d90) {
  "llh.symbolic_int"() <{sym_name = "s3"}> : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llh.symbolic_int'(0x55e33ca99de0) {
  "llh.symbolic_int"() <{sym_name = "s2"}> : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llh.symbolic_int'(0x55e33ca99e30) {
  "llh.symbolic_int"() <{sym_name = "s1"}> : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llh.symbolic_int'(0x55e33ca9ae90) {
  "llh.symbolic_int"() <{sym_name = "c64"}> : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llh.symbolic_int'(0x55e33ca9b360) {
  "llh.symbolic_int"() <{sym_name = "s0"}> : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0x55e33caab1e0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llh.add'(0x55e33caab380) {
  %0 = "llh.add"(%arg0, %arg1) : (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>) -> tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>

ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasRecursiveMemoryEffects<mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects>()::Empty>)
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llh.add'(0x55e33caab910) {
  %1 = "llh.add"(%arg1, %arg1) : (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>) -> tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x55e33ca9d220) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'builtin.module'(0x55e33caac570) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llh.symbol_relation'(0x55e33ca9d050) {
  "llh.symbol_relation"() <{relation = @s5, relation_kind = #llh.SymbolRelation<EQ>, symbol = @s2}> : () -> ()


  * Pattern {anonymous}::ReplaceSymbolIfEquel : 'llh.symbol_relation -> ()' {
Trying to match "{anonymous}::ReplaceSymbolIfEquel"
"llh.symbolic_int"() <{sym_name = "s5"}> : () -> ()
"llh.symbolic_int"() <{sym_name = "s4"}> : () -> ()
"llh.symbolic_int"() <{sym_name = "s3"}> : () -> ()
"llh.symbolic_int"() <{sym_name = "s2"}> : () -> ()
"llh.symbolic_int"() <{sym_name = "s1"}> : () -> ()
"llh.symbolic_int"() <{sym_name = "c64"}> : () -> ()
"llh.symbolic_int"() <{sym_name = "s0"}> : () -> ()
func.func @main(%arg0: tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>, %arg1: tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>) attributes {entrance} {
  %0 = "llh.add"(%arg0, %arg1) : (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>) -> tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>
  %1 = "llh.add"(%arg1, %arg1) : (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>) -> tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>
  return
}
module @__symbol__ {
  "llh.symbol_relation"() <{relation = @s5, relation_kind = #llh.SymbolRelation<EQ>, symbol = @s2}> : () -> ()
  "llh.symbol_relation"() <{relation = @s4, relation_kind = #llh.SymbolRelation<EQ>, symbol = @s1}> : () -> ()
  "llh.symbol_relation"() <{relation = @s3, relation_kind = #llh.SymbolRelation<EQ>, symbol = @s0}> : () -> ()
  "llh.symbol_relation"() <{relation = @s3, relation_kind = #llh.SymbolRelation<EQ>, symbol = @s0}> : () -> ()
}
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s2>>')
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
%0 = "llh.add"(%arg0, %arg1) : (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>) -> tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s2>>')
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
%1 = "llh.add"(%arg1, %arg1) : (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>) -> tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s2>>')
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.return"() : () -> ()
"{anonymous}::ReplaceSymbolIfEquel" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @__symbol__ {
  "llh.symbol_relation"() <{relation = @s4, relation_kind = #llh.SymbolRelation<EQ>, symbol = @s1}> : () -> ()
  "llh.symbol_relation"() <{relation = @s3, relation_kind = #llh.SymbolRelation<EQ>, symbol = @s0}> : () -> ()
  "llh.symbol_relation"() <{relation = @s3, relation_kind = #llh.SymbolRelation<EQ>, symbol = @s0}> : () -> ()
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llh.symbol_relation'(0x55e33ca9b430) {
  "llh.symbol_relation"() <{relation = @s4, relation_kind = #llh.SymbolRelation<EQ>, symbol = @s1}> : () -> ()


  * Pattern {anonymous}::ReplaceSymbolIfEquel : 'llh.symbol_relation -> ()' {
Trying to match "{anonymous}::ReplaceSymbolIfEquel"
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s2>>')
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"llh.symbolic_int"() <{sym_name = "s5"}> : () -> ()
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s2>>')
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"llh.symbolic_int"() <{sym_name = "s4"}> : () -> ()
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s2>>')
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"llh.symbolic_int"() <{sym_name = "s3"}> : () -> ()
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s2>>')
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"llh.symbolic_int"() <{sym_name = "s2"}> : () -> ()
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s2>>')
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"llh.symbolic_int"() <{sym_name = "s1"}> : () -> ()
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s2>>')
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"llh.symbolic_int"() <{sym_name = "c64"}> : () -> ()
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s2>>')
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"llh.symbolic_int"() <{sym_name = "s0"}> : () -> ()
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s2>>')
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.func"() <{function_type = (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s2>>) -> (), sym_name = "main"}> ({
^bb0(%arg0: tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>, %arg1: tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>):
  %0 = "llh.add"(%arg0, %arg1) : (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>) -> tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>
  %1 = "llh.add"(%arg1, %arg1) : (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>) -> tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>
  "func.return"() : () -> ()
}) {entrance} : () -> ()
module @__symbol__ {
  "llh.symbol_relation"() <{relation = @s4, relation_kind = #llh.SymbolRelation<EQ>, symbol = @s1}> : () -> ()
  "llh.symbol_relation"() <{relation = @s3, relation_kind = #llh.SymbolRelation<EQ>, symbol = @s0}> : () -> ()
  "llh.symbol_relation"() <{relation = @s3, relation_kind = #llh.SymbolRelation<EQ>, symbol = @s0}> : () -> ()
}
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s1, @s2>>')
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
%0 = "llh.add"(%arg0, %arg1) : (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>) -> tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s1, @s2>>')
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
%1 = "llh.add"(%arg1, %arg1) : (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>) -> tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s1, @s2>>')
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.return"() : () -> ()
"{anonymous}::ReplaceSymbolIfEquel" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @__symbol__ {
  "llh.symbol_relation"() <{relation = @s3, relation_kind = #llh.SymbolRelation<EQ>, symbol = @s0}> : () -> ()
  "llh.symbol_relation"() <{relation = @s3, relation_kind = #llh.SymbolRelation<EQ>, symbol = @s0}> : () -> ()
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llh.symbol_relation'(0x55e33ca93b00) {
  "llh.symbol_relation"() <{relation = @s3, relation_kind = #llh.SymbolRelation<EQ>, symbol = @s0}> : () -> ()


  * Pattern {anonymous}::ReplaceSymbolIfEquel : 'llh.symbol_relation -> ()' {
Trying to match "{anonymous}::ReplaceSymbolIfEquel"
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s1, @s2>>')
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"llh.symbolic_int"() <{sym_name = "s5"}> : () -> ()
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s1, @s2>>')
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"llh.symbolic_int"() <{sym_name = "s4"}> : () -> ()
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s1, @s2>>')
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"llh.symbolic_int"() <{sym_name = "s3"}> : () -> ()
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s1, @s2>>')
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"llh.symbolic_int"() <{sym_name = "s2"}> : () -> ()
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s1, @s2>>')
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"llh.symbolic_int"() <{sym_name = "s1"}> : () -> ()
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s1, @s2>>')
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"llh.symbolic_int"() <{sym_name = "c64"}> : () -> ()
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s1, @s2>>')
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"llh.symbolic_int"() <{sym_name = "s0"}> : () -> ()
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s1, @s2>>')
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.func"() <{function_type = (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s1, @s2>>) -> (), sym_name = "main"}> ({
^bb0(%arg0: tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>, %arg1: tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>):
  %0 = "llh.add"(%arg0, %arg1) : (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>) -> tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>
  %1 = "llh.add"(%arg1, %arg1) : (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>) -> tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>
  "func.return"() : () -> ()
}) {entrance} : () -> ()
module @__symbol__ {
  "llh.symbol_relation"() <{relation = @s3, relation_kind = #llh.SymbolRelation<EQ>, symbol = @s0}> : () -> ()
  "llh.symbol_relation"() <{relation = @s3, relation_kind = #llh.SymbolRelation<EQ>, symbol = @s0}> : () -> ()
}
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>')
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
%0 = "llh.add"(%arg0, %arg1) : (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>) -> tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>')
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
%1 = "llh.add"(%arg1, %arg1) : (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>) -> tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>')
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.return"() : () -> ()
"{anonymous}::ReplaceSymbolIfEquel" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @__symbol__ {
  "llh.symbol_relation"() <{relation = @s3, relation_kind = #llh.SymbolRelation<EQ>, symbol = @s0}> : () -> ()
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llh.symbol_relation'(0x55e33ca93930) {
  "llh.symbol_relation"() <{relation = @s3, relation_kind = #llh.SymbolRelation<EQ>, symbol = @s0}> : () -> ()


  * Pattern {anonymous}::ReplaceSymbolIfEquel : 'llh.symbol_relation -> ()' {
Trying to match "{anonymous}::ReplaceSymbolIfEquel"
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>')
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"llh.symbolic_int"() <{sym_name = "s5"}> : () -> ()
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>')
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"llh.symbolic_int"() <{sym_name = "s4"}> : () -> ()
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>')
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"llh.symbolic_int"() <{sym_name = "s3"}> : () -> ()
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>')
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"llh.symbolic_int"() <{sym_name = "s2"}> : () -> ()
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>')
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"llh.symbolic_int"() <{sym_name = "s1"}> : () -> ()
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>')
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"llh.symbolic_int"() <{sym_name = "c64"}> : () -> ()
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>')
mlir-asm-printer: 'builtin.module' failed to verify and will be printed in generic form
"llh.symbolic_int"() <{sym_name = "s0"}> : () -> ()
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>')
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.func"() <{function_type = (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>) -> (), sym_name = "main"}> ({
^bb0(%arg0: tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>, %arg1: tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>):
  %0 = "llh.add"(%arg0, %arg1) : (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>) -> tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>
  %1 = "llh.add"(%arg1, %arg1) : (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>) -> tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>
  "func.return"() : () -> ()
}) {entrance} : () -> ()
module @__symbol__ {
  "llh.symbol_relation"() <{relation = @s3, relation_kind = #llh.SymbolRelation<EQ>, symbol = @s0}> : () -> ()
}
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>')
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
%0 = "llh.add"(%arg0, %arg1) : (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>) -> tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>')
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
%1 = "llh.add"(%arg1, %arg1) : (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>) -> tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>
'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>')
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.return"() : () -> ()
"{anonymous}::ReplaceSymbolIfEquel" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @__symbol__ {
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llh.symbolic_int'(0x55e33ca98af0) {
  "llh.symbolic_int"() <{sym_name = "s5"}> : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llh.symbolic_int'(0x55e33ca98fc0) {
  "llh.symbolic_int"() <{sym_name = "s4"}> : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llh.symbolic_int'(0x55e33ca99d90) {
  "llh.symbolic_int"() <{sym_name = "s3"}> : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llh.symbolic_int'(0x55e33ca99de0) {
  "llh.symbolic_int"() <{sym_name = "s2"}> : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llh.symbolic_int'(0x55e33ca99e30) {
  "llh.symbolic_int"() <{sym_name = "s1"}> : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llh.symbolic_int'(0x55e33ca9ae90) {
  "llh.symbolic_int"() <{sym_name = "c64"}> : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llh.symbolic_int'(0x55e33ca9b360) {
  "llh.symbolic_int"() <{sym_name = "s0"}> : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.func'(0x55e33caab1e0) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llh.add'(0x55e33caab380) {
  %0 = "llh.add"(%arg0, %arg1) : (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>) -> tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'llh.add'(0x55e33caab910) {
  %1 = "llh.add"(%arg1, %arg1) : (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>) -> tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x55e33ca9d220) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'builtin.module'(0x55e33caac570) {
} -> failure : pattern failed to match
//===-------------------------------------------===//
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::PreservedAnalyses::AllAnalysesType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::AttributeTrait::IsLocation<mlir::TypeID::get<mlir::AttributeTrait::IsLocation>()::Empty>)
within split at /home/lfr/LLCompiler/test/Dialect/LLH/canonicalize_symbol.mlir:1 offset :13:3: error: 'func.func' op type of entry block argument #1('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>') must match the type of the corresponding argument in function signature('tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>')
  func.func @main(%arg0: tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>, %arg1: tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>) attributes {entrance} {
  ^
within split at /home/lfr/LLCompiler/test/Dialect/LLH/canonicalize_symbol.mlir:1 offset :13:3: note: see current operation: 
"func.func"() <{function_type = (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>) -> (), sym_name = "main"}> ({
^bb0(%arg0: tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>, %arg1: tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>):
  %0 = "llh.add"(%arg0, %arg1) : (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>) -> tensor<?x64x?x?xf32, #llh.encoding<shapes = @s0, @c64, @s1, @s2>>
  %1 = "llh.add"(%arg1, %arg1) : (tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>, tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>) -> tensor<?x64x?x?xf32, #llh.encoding<shapes = @s3, @c64, @s4, @s5>>
  "func.return"() : () -> ()
}) {entrance} : () -> ()
